# A0108535H
###### \src\snaptask\logic\Command.java
``` java
public enum Command {
	ADD, EDIT, DELETE, SEARCH, UNDO, DONE, DISPLAY, INVALID, CLEAR, FILTER, SORT, HISTORY, HELP, HOME, FILESTORAGE
}
```
###### \src\snaptask\logic\TaskManager.java
``` java
/**
 * This class is the main logic of the whole application, takes input from UI,
 * pass it into parser to get the command and then operate.
 * 
 * returns to UI and also saves
 */
public class TaskManager implements Serializable {
	private static final long serialVersionUID = 5891852874329459561L;
	
	private static List<Task> tasks;
	private static List<Task> temporaryTasks;
	private static List<String> history = new ArrayList<String>();
	
	private static TaskManager instance = null;
	private static Parser parser;
	private static Storage storage;
	private static final Logger logger = Logger.getLogger(TaskManager.class.getName());
	private static String dueTask = null;
	private static Timer globalTimer = new Timer(0,null);
	
	private static Stack<Task> undo = new Stack<Task>();
	private static Stack<Command> operand = new Stack<Command>();

	private static boolean hasAlertTimer = false;
	public boolean filtered = false;
	
	DateFormat df = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss aa");
/**
 * This method will construct an instance of the class TaskManager for the Application Window to interact with.
 * 
 * @return: The instance of TaskManager that is constructed, with variables initialised.
 * @throws FileNotFoundException: If the tasks are unable to be loaded from the file.
 * @throws IOException: If the there is a problem related to the reading the tasks from the storage.
 */
	public static TaskManager getInstance() throws FileNotFoundException, IOException {
		if (instance == null) {
			instance = new TaskManager();
			tasks = new ArrayList<Task>();
			temporaryTasks = new ArrayList<Task>();
			parser = Parser.getInstance();
			storage = new Storage();
			loadTasks();
			logger.log(Level.FINE, "Program initialised with tasks loaded from file.");
		}
		return instance;
	}
	
/**
 * This method will load the tasks in the saved tasks file whenever the program is opened. 
 *
 * @throws IOException: If the there is a problem related to the reading the tasks from the storage, i.e. the objects are not in the correct format.
 */
	public static void loadTasks() throws IOException {
		tasks = storage.readTasks();
	}

	/**
	 * This method returns the existing list that the taskManager has in its memory.
	 * @return: The existing task list
	 */
	public List<Task> existingList() {
		return tasks;
	}

	/**
	 * This method replaces the current tasks that the taskManager has in memory with a new list.
	 * 
	 * @param list: The list that will replace the old taskManager list.
	 */
	public void newList(List<Task> list) {
		tasks = list;
	}

	/**
	 * This method cycles through all of the tasks in memory and outputs all task names as an array.
	 *
	 * @return: The array of task names that are in memory.
	 */
	public String[] getTaskNames() {
		String[] taskNames;
		if (!filtered) {
			taskNames = new String[tasks.size()];
			for (int i = 0; i < tasks.size(); i++) {
				taskNames[i] = i + ": " + tasks.get(i).getName();
			}
		} else {
			taskNames = new String[temporaryTasks.size()];
			for (int i = 0; i < temporaryTasks.size(); i++) {
				taskNames[i] = i + ": " + temporaryTasks.get(i).getName();
			}
		}
		return taskNames;
	}
	
	/**
	 * This method returns all of the tasks as a list that are in memory. If the result is filtered or sorted, it will return the temporaryTasks list.
	 * 
	 * @return: The task list to be returned
	 */
	public List<Task> getTasks() {
		if (!filtered) {
			return tasks;
		} else {
			return temporaryTasks;
		}
	}

	/**
	 * This method returns the number of tasks that are currently in memory.
	 * 
	 * @return: The number of tasks in memory
	 */
	public int getNumberOfTasks() {
		if (filtered) {
			return temporaryTasks.size();
		} else {
			return tasks.size();
		}
	}
	
	/**
	 * This method returns all of the recent history actions that are in memory.
	 * 
	 * @return: A list of the recent history actions.
	 */
	public List<String> getHistoryList() {
		return history;
	}

	/**
	 * This method removes a task at a specified index from its memory.
	 * 
	 * @param index: The index to delete the task from memory at
	 */
	private void removeTask(int index) {
		tasks.remove(index);
	}

	/**
	 * This function returns a task that is at a specified index in memory.
	 * 
	 * @param index: The specified index to obtain the task from in memory.
	 * @return: The task to be returned.
	 */
	public Task getTask(int index) {
		if (filtered) {
			return temporaryTasks.get(index);
		} else {
			return tasks.get(index);
		}
	}

	/**
	 * This function returns the index of a specific task in memory.
	 * 
	 * @param task: The task to be searched for in memory.
	 * @return: Returns -1 if the task cannot be found or the index.
	 */
	public int getIndexOfTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (task == tasks.get(i)) {
				return i;
			}
		}
		return -1;
	}


    private static void setAlertForComingTasks(final ApplicationWindow window) {
        Date currentDate = new Date();
        Date smallestTime = null;
        Boolean hasDueTask = false;
        // search for the latest && undone && have start-time task.
        for (Task task : tasks) {
            if (task.getTimeStart() != null // have start-time
                    && !task.getDoneStatus() // not done
                    && task.getTimeStart().after(currentDate)) {
                if (smallestTime == null) {
                    smallestTime = task.getTimeStart();
                    dueTask = task.displayString();
                    hasDueTask = true;
                } else if (task.getTimeStart().before(smallestTime)) {
                    smallestTime = task.getTimeStart();
                    dueTask = task.displayString();
                    hasDueTask = true;
                }
            }
        }

        ActionListener taskPerformer = new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                window.showMessage("TIMES UP!!!!  for this task\n" + dueTask);
                // hasAlertTimer = false;
                setAlertForComingTasks(window);
            }
        };
        // sets the timer only if there is a upcoming task
        System.out.println(smallestTime + " " + hasDueTask.toString());
        if (smallestTime != null && hasDueTask) {
            long delay = smallestTime.getTime() - currentDate.getTime(); // milliseconds

            // stops all current alerts
            if (globalTimer.isRunning()) {
                globalTimer.stop();

            }

            // removes all existing listeners
            ActionListener[] existingActions = globalTimer.getActionListeners();
            for (ActionListener actions : existingActions) {
                globalTimer.removeActionListener(actions);
                System.out.println("removed some");
            }
            // add new listeners
            globalTimer.addActionListener(taskPerformer);
            globalTimer.setInitialDelay((int) delay + 50);
            globalTimer.setRepeats(false);
            // add a new alert
            globalTimer.start();
            System.out.println(globalTimer.isRunning());
            hasAlertTimer = true;

        } else {
            hasAlertTimer = false;
        }
    }

    //call this to setAlerts
    public void setAlerts(final ApplicationWindow window) {

        if (!hasAlertTimer) {
            // alerts for the first time based on existing tasks
            setAlertForComingTasks(window);
            System.out.println("no has timer");
        } else {
            setAlertForComingTasks(window);
            System.out.println("hastimer");
        }
    }


    /**
     * This method sorts of the list of tasks in memory so that the most urgent, or closest to the current date,
     * are at the top. Tasks that do not have a time or date are automatically at the bottom.
     */
	public void sortAndRefresh() {
		Collections.sort(tasks, new Comparator<Task>() {
			@Override
			public int compare(Task lhs, Task rhs) {
				if (lhs.isExactTime() && !rhs.isExactTime()) {
					return -1;
				} else if (lhs.isExactTime() && rhs.isExactTime()) {
					return lhs.getTimeStart().getTime() < rhs.getTimeStart().getTime()
							? -1
									: (lhs.getTimeStart().getTime() < rhs.getTimeStart()
											.getTime()) ? 1 : 0;
				} else {
					return 0;
				}

			}
		});
	}

	/**
	 * This function will execute a command given an input as supplied by the user. 
	 * 
	 * 
	 * @param input: The String input that is supplied by user, the command and parameters are contained here.
	 * @param window: The ApplicationWindow which is to be updated.
	 * @throws NoInputException: No input has been entered
	 * @throws InvalidInputException: The input entered is invalid and not does have correct commands/parameters
	 * @throws InvalidTaskTimeException: The input entered contains an invalid task time.
	 * @throws TaskTimeOutOfBoundException: The input entered contains a time that is out of bounds.
	 * @throws TaskDateAlreadyPassedException: The input entered contains a date that has already passed.
	 * @throws InvalidTaskDateException: The input entered contains a date that does not exist.
	 * @throws ArgumentForEditingNotEnteredException: The input entered does not contain the correct arguments for editing.
	 * @throws InvalidDateTimeFormatException: The input entered does not contain the correct format for date and time.
	 * @throws KeywordNotEnteredException: The input entered does not contain any keywords.
	 * @throws SearchTypeNotEnteredException: The input entered does not contain a search type.
	 * @throws SearchNotInPairException: The input entered does not contain a keyword for the pair type.
	 * @throws FileNotFoundException: The task was unable to be saved as the save file was not found.
	 * @throws UnsupportedEncodingException: The task was unable to be encoded to the file.
	 * @throws FileTypeInvalidException: The selected file type for the save file is invalid.
	 * @throws InvalidTaskDurationException: The duration for the task time is invalid.
	 */
	public void executeCommand(String input, ApplicationWindow window)
			throws NoInputException, InvalidInputException, InvalidTaskTimeException,
			TaskTimeOutOfBoundException, TaskDateAlreadyPassedException,
			InvalidTaskDateException, ArgumentForEditingNotEnteredException,
			InvalidDateTimeFormatException, KeywordNotEnteredException,
			SearchTypeNotEnteredException, SearchNotInPairException,
			FileNotFoundException, UnsupportedEncodingException,
			FileTypeInvalidException, InvalidTaskDurationException {
		window.selectedButtonIndex = 0;
		window.refreshWindow();
		Command commandType = parser.getCommand(input);
		assert (commandType != null);
		switch (commandType) {
		case ADD :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				Task task = null;
				try {
					task = parser.getAddingParser().getTaskForAdding(input);
				} catch (Exception e) {
					logger.log(Level.SEVERE, e.toString(), e);
					e.printStackTrace();
				}
				addTask(task);
				setAlertForComingTasks(window);
				sortAndRefresh();
				addOnUndoStack(commandType, task);
			}
			break;
		case DELETE :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				int deleteIndex;
				try {
					deleteIndex = parser.getDeletingParser().getTaskIndex(input);
				} catch (Exception e) {
					logger.log(Level.SEVERE, e.toString(), e);
					e.printStackTrace();
					break;
				}
				if (deleteIndex >= 0 && deleteIndex <= getNumberOfTasks()) {
					addOnUndoStack(commandType, tasks.get(deleteIndex - 1));
					removeTask(deleteIndex - 1);
					logger.log(Level.FINE, "task with index {0} removed.",
							deleteIndex);
				}
			}
			break;
		case EDIT :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				int index = parser.getEditingParser().findTokenIndex(input);
				addOnUndoStack(commandType, index - 1);
				editTask(input);
				sortAndRefresh();
			}
			break;
		case CLEAR :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				removeAllTasks(commandType);
			}
			break;
		case SEARCH :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				searchTask(input, window);
			}
			break;
		case DONE :
			if (filtered) {
				window.showMessage("You cannot perform this operation when applying a filter or search. Resetting list to all. ");
				filtered = false;
				window.refreshWindow();
			} else {
				completeTask(input);
			}
			break;
		case UNDO :
			undo(window);
			logger.log(Level.FINE, "Undo the last operation.");
			break;
		case FILESTORAGE :
			changeFileStore(input);
			break;
		case DISPLAY :
			displayTask(input, window);
			window.setTaskDetailView();
			break;
		case HISTORY :
			window.selectedButtonIndex = 1;
			window.refreshWindow();
			break;
		case HOME :
			window.selectedButtonIndex = 0;
			window.refreshWindow();
			break;
		case HELP :
			window.selectedButtonIndex = 2;
			window.refreshWindow();
			break;
		case FILTER :
			filterTasks(input, window);
			break;
		case SORT:
			sortTasks(input, window);
			break;
		default :
			throw new InvalidInputException();
		}
		storage.saveTasks(tasks);
		logger.log(Level.FINE, "Tasks saved.");
	}

	
	private void changeFileStore(String input) throws FileTypeInvalidException,
	FileNotFoundException, UnsupportedEncodingException {
		StorageParserType commandType = parser.getStorageParser()
				.findStorageParserType(input);

		switch (commandType) {
		case CHANGEPATH :
			storage.setPath(Parser.divideTokens(input)[2]);
			break;
		case CHANGENAME :
			storage.setFileName(Parser.divideTokens(input)[2]);
			break;
		case READPATH :
			System.out.println(storage.getPath());
			break;
		default :
		}
	}

	/**
	 * This method filters the tasks according to a selected filter and then updates the temporary storage.
	 * 
	 * @param input: The input entered by the user containing the filter type.
	 * @param window: The window which will receive any updates.
	 */
	private void filterTasks(String input, ApplicationWindow window) {
		String filterType = Parser.divideTokens(input)[1];
		System.out.println(filterType);
		switch (filterType) {
		case "incomplete" :
			filterIncomplete(window);
			window.filterDropdown.setSelectedIndex(1);
			break;
		case "complete" :
			filterComplete(window);
			window.filterDropdown.setSelectedIndex(2);
			break;
		case "short" :
			filterShort(window);
			window.filterDropdown.setSelectedIndex(3);
			break;
		case "medium" :
			filterMedium(window);
			window.filterDropdown.setSelectedIndex(4);
			break;
		case "long" :
			filterLong(window);
			window.filterDropdown.setSelectedIndex(5);
			break;
		case "soon" :
			filterSoon(window);
			window.filterDropdown.setSelectedIndex(6);
			break;
		case "all" :
			filterAll(window);
			window.filterDropdown.setSelectedIndex(0);
			break;
		default :
			window.showMessage("Invalid filter option. ");
		}
	}

	/**
	 * This method ensures only tasks that are incomplete are shown.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterIncomplete(ApplicationWindow window) {
		temporaryTasks.clear();
		for (Task task : tasks) {
			if (!task.getDoneStatus()) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method ensures only tasks that are complete are shown.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterComplete(ApplicationWindow window) {
		temporaryTasks.clear();
		for (Task task : tasks) {
			if (task.getDoneStatus()) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method filters tasks that are considered short (under one hour).
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterShort(ApplicationWindow window) {
		temporaryTasks.clear();
		for (Task task : tasks) {
			if (task.getDuration() != 0 && task.getDuration() < 60) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method filters tasks that are considered medium (between one and three hours).
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterMedium(ApplicationWindow window) {
		temporaryTasks.clear();
		for (Task task : tasks) {
			if (task.getDuration() != 0 && task.getDuration() >= 60
					&& task.getDuration() <= 180) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method filters tasks that are considered long (over three fours).
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterLong(ApplicationWindow window) {
		temporaryTasks.clear();
		for (Task task : tasks) {
			if (task.getDuration() != 0 && task.getDuration() > 180) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method filters tasks that will be happening soon (today or tomorrow).
	 * 
	 * @param window: The window which will receive any updates.
	 */
	@SuppressWarnings("deprecation")
	private void filterSoon(ApplicationWindow window) {
		temporaryTasks.clear();
		Date currentDate = new Date();
		for (Task task : tasks) {
			if (task.getTimeStart() != null
					&& task.getTimeStart().getYear() == currentDate.getYear()
					&& (task.getTimeStart().getDay() == currentDate.getDay() || Math.abs(
							task.getTimeStart().getDay() - currentDate.getDay()) == 1)
					&& task.getTimeStart().getMonth() == currentDate.getMonth()) {
				temporaryTasks.add(task);
			}
		}
		filtered = true;
		window.refreshWindow();
	}

	/**
	 * This method resets the filter back to the default filter and refreshes the window.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void filterAll(ApplicationWindow window) {
		filtered = false;
		window.refreshWindow();
	}

	/**
	 * This function sorts tasks according to a given keyword and ensures the dropdown index is properly selected.
	 * 
	 * @param input: The input has obtained from the user containing the sort type.
	 * @param window: The window which will receive any updates.
	 */
	private void sortTasks(String input, ApplicationWindow window) {
		String filterType = Parser.divideTokens(input)[1];
		System.out.println(filterType);
		switch (filterType) {
		case "name" :
			sortName(window);
			window.sortDropdown.setSelectedIndex(1);
			break;
		case "date" :
			sortAndRefresh();
			window.refreshWindow();
			window.sortDropdown.setSelectedIndex(2);
			filtered = false;
			break;
		case "start" :
			sortStart(window);
			window.sortDropdown.setSelectedIndex(3);
			break;
		case "end" :
			sortEnd(window);
			window.sortDropdown.setSelectedIndex(4);
			break;
		case "duration" :
			sortDuration(window);
			window.sortDropdown.setSelectedIndex(5);
			break;
		case "default" :
			sortAndRefresh();
			window.refreshWindow();
			window.sortDropdown.setSelectedIndex(0);
			filtered = false;
			break;
		default :
			window.showMessage("Invalid sort option." );
		}
	}

	/**
	 * This function is responsible for sorting the tasks alphabetically by name.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void sortName(ApplicationWindow window) {
		Collections.sort(tasks, new Comparator<Task>() {
			@Override
			public int compare(Task lhs, Task rhs) {				
				if (lhs.getName().equals(rhs.getName())) {
					return 0;
				} else if (lhs.getName().compareTo(rhs.getName()) > 0) {
					return 1;
				} else {
					return -1;
				}

			}
		});
		window.refreshWindow();
	}

	/**
	 * This function is responsible for sorting the tasks by start time.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void sortStart(ApplicationWindow window) {
		Collections.sort(tasks, new Comparator<Task>() {
			@SuppressWarnings("deprecation")
			@Override
			public int compare(Task lhs, Task rhs) {
				if (lhs.isExactTime() && !rhs.isExactTime()) {
					return -1;
				} else if (lhs.isExactTime() && rhs.isExactTime()) {
					if (lhs.getTimeStart().getHours() < rhs.getTimeStart().getHours()) {
						return -1;
					} else if (lhs.getTimeStart().getHours() > rhs.getTimeStart().getHours()) {
						return 1;
					} else if (lhs.getTimeStart().getMinutes() < rhs.getTimeStart().getMinutes()) {
						return -1;
					} else if (lhs.getTimeStart().getMinutes() > rhs.getTimeStart().getMinutes()) {
						return 1;
					} else {
						return 0;
					}
				} else {
					return 0;
				}
			}
		});
	}

	/**
	 * This function is responsible for sorting the tasks by end time.
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void sortEnd(ApplicationWindow window) {
		Collections.sort(tasks, new Comparator<Task>() {
			@SuppressWarnings("deprecation")
			@Override
			public int compare(Task lhs, Task rhs) {
				if (lhs.isExactTime() && !rhs.isExactTime() && lhs.getDuration() == 0 && rhs.getDuration() == 0) {
					return -1;
				} else if (lhs.isExactTime() && rhs.isExactTime() && lhs.getDuration() != 0 && rhs.getDuration() != 0) {
					if (lhs.getEndTime().getHours() < rhs.getEndTime().getHours()) {
						return -1;
					} else if (lhs.getEndTime().getHours() > rhs.getEndTime().getHours()) {
						return 1;
					} else if (lhs.getEndTime().getMinutes() < rhs.getEndTime().getMinutes()) {
						return -1;
					} else if (lhs.getEndTime().getMinutes() > rhs.getEndTime().getMinutes()) {
						return 1;
					} else {
						return 0;
					}
				} else {
					return 0;
				}
			}
		});
	}

	/**
	 * This function is responsible for sorting the tasks by duration (short to long).
	 * 
	 * @param window: The window which will receive any updates.
	 */
	private void sortDuration(ApplicationWindow window) {
		Collections.sort(tasks, new Comparator<Task>() {
			@Override
			public int compare(Task lhs, Task rhs) {
				if (lhs.getDuration() == 0 && rhs.getDuration() == 0) {
					return -1;
				} else if (lhs.getDuration() != 0 && rhs.getDuration() != 0) {
					if (lhs.getDuration() < rhs.getDuration()) {
						return -1;
					} else if (lhs.getDuration() > rhs.getDuration()) {
						return 1;
					} else {
						return 0;
					}
				} else {
					return 0;
				}
			}
		});
	}


	/**
	 * This function is responsible for displaying a task on the supplied ApplicationWindow.
	 * 
	 * @param input: The input as supplied by the user which contains the index to be displayed.
	 * @param window: The window which will receive any updates.
	 */
	private void displayTask(String input, ApplicationWindow window) {
		int index = parser.getEditingParser().findTokenIndex(input);
		if (index <= window.table.getRowCount() && index > 0) {
			window.selectedListIndex = index - 1;
		} else {
			window.showMessage("The index entered was invalid. ");
		}
	}

	/**
	 * This method is responsible for clearing all tasks from the taskManager's memory.
	 * 
	 * @param commandType: The command type which is added on to the undo stack.
	 */
	private void removeAllTasks(Command commandType) {
		int numOfTasks = getNumberOfTasks();

		for (int i = numOfTasks - 1; 0 <= i; i--) {
			addOnUndoStack(commandType, tasks.get(i));
			removeTask(i);
		}

	}

	private void addOnUndoStack(Command commandType, int index) {
		Task task = tasks.get(index);
		assert (task != null);
		addOnUndoStack(commandType, new Task(task.getName(), task.getTimeStart(),
				task.isExactTime(), task.getDuration()));
		addOnUndoStack(commandType, tasks.get(index));
	}

	private void addOnUndoStack(Command commandType, Task task) {
		undo.push(task);
		operand.push(commandType);
		Date now = new Date();
		DateFormat dateFormat = new SimpleDateFormat("HH:mm aa, dd MMMM yyyy");
		String time = dateFormat.format(now);
		history.add(commandType + " on task " + task.getName() + " at " + time);
	}

	private void undo(ApplicationWindow window) {

		if (operand.empty()) {
			return;
		}

		Task task = undo.pop();
		Command op = operand.pop();
		switch (op) {
		case ADD :
			int indexAdd = getIndexOfTask(task);
			removeTask(indexAdd);
			break;
		case DELETE :
			addTask(task);
			break;
		case CLEAR :

			do {
				addTask(task);

				if (operand.empty()) {
					return;
				}

				op = operand.pop();
				task = undo.pop();

			} while (op == Command.CLEAR);

			undo.push(task);
			operand.push(op);

			break;
		case EDIT :
			int indexEdit = getIndexOfTask(task);
			removeTask(indexEdit);

			task = undo.pop();
			operand.pop();

			addTask(task);
			break;
		default :
			break;

		}
		window.refreshWindow();
	}

	private void completeTask(String input) {
		assert (input != null);
		int index = parser.getEditingParser().findTokenIndex(input);
		getTask(index - 1).setDoneStatus(true);
		logger.log(Level.FINE, "Task {0} has been marked as done.", index);
	}

	private void editTask(String input) throws InvalidTaskTimeException,
	TaskTimeOutOfBoundException, InvalidInputException,
	TaskDateAlreadyPassedException, InvalidTaskDateException,
	ArgumentForEditingNotEnteredException, InvalidDateTimeFormatException, InvalidTaskDurationException {
		assert (input != null);
		int index = parser.getEditingParser().findTokenIndex(input) - 1;
		EditType editType = parser.getEditingParser().findEditTaskType(input);
		if (editType == EditType.DATETIME) {
			Date date = parser.getEditingParser().extractDateTokens(input);
			getTask(index).setTimeStart(date);
			logger.log(Level.FINE,
					"Date and time of the task {0} has been changed to {1}.",
					new Object[] {index, df.format(date)});
		} else if (editType == EditType.NAME) {
			String name = parser.getEditingParser().getArgumentForEditing(input);
			getTask(index).setName(name);
			logger.log(Level.FINE, "Name of the task {0} has been changed to {1}.",
					new Object[] {index, name});
		} else {
			int duration = parser.getEditingParser().getEditDurationArgument(input);
			getTask(index).setDuration(duration);
			logger.log(Level.FINE, "Duration of the task {0} has been changed to {1}",
					new Object[] {index, duration});
		}
	}

	private void searchTask(String input, ApplicationWindow window) throws KeywordNotEnteredException,
	SearchTypeNotEnteredException, SearchNotInPairException {
		assert (input != null);
		String nameToSearchFor = parser.getSearchingParser().getNameForSearch(input);
		boolean contains = false;
		int occurance = 0;
		temporaryTasks.clear();
		filtered = true;
		for (Task currentTasks : tasks) {
			contains = currentTasks.getName().toLowerCase()
					.contains(nameToSearchFor.toLowerCase());
			if (contains) {
				temporaryTasks.add(currentTasks);
				occurance++;
			}
		}
		window.refreshWindow();
		window.showMessage("A total of: " + occurance + " occurences were found.");
	}

	private void addTask(Task task) {
		boolean canAddTask = true;
		if (tasks == null) {
			tasks.add(task);
		} else if (task.isExactTime()) {
			Date newTaskTimeStart = task.getTimeStart();
			for (Task currentTasks : tasks) {
				Date oldTaskTimeStart = currentTasks.getTimeStart();
				if (newTaskTimeStart.equals(oldTaskTimeStart)) {
					canAddTask = false;
					System.out.println("task start-time is the same");
				} else if (currentTasks.isExactTime() && canAddTask) {
					canAddTask = isClash(task, currentTasks);
				}
			}
		}
		if (canAddTask) {
			tasks.add(task);
		} else {
			tasks.add(task);
			System.out.println("there is a clash, but task still added");
		}
	}

	private boolean isClash(Task task, Task currentTasks) {
		assert (task != null);
		long taskTime = task.getTimeStart().getTime();
		int taskDuration = task.getDuration() * 1000 * 60;
		long currentTaskTime = currentTasks.getTimeStart().getTime();
		int currentTaskDuration = currentTasks.getDuration() * 1000 * 60;
		if (task.getTimeStart().after(currentTasks.getTimeStart())) {
			if (taskTime - currentTaskTime >= currentTaskDuration) {
				return true; // doesnt clash
			}
		} else {
			if (currentTaskTime - taskTime >= taskDuration) {
				return true; // doesnt clash
			}
		}
		return false;
	}

	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();
		int i = 0;
		for (Task task : tasks) {
			sb.append("Task " + i + ": " + task.toString());
			i++;
		}
		return sb.toString();
	}
}
```
###### \tests\snaptask\logic\TaskManagerTest.java
``` java
public class TaskManagerTest {

    TaskManager tm;
    public TaskManager taskManager;
    public List<Task> existingTasks;
    public List<Task> workingTasks;

    @Before
    public void initialise() throws FileNotFoundException, IOException {
        tm = new TaskManager();
        taskManager = TaskManager.getInstance();
        existingTasks = taskManager.existingList();
        workingTasks=existingTasks;
        try {
            Task task1 = new Task("first", DateTime.getExactDate("21/11/2018 19:00", 0),
                    true, 200);
            Task task2 = new Task("2nd", DateTime.getExactDate("22/11/2018 12:00", 0), true,
                    120);
            Task task3 = new Task("3rd", DateTime.getExactDate("23/11/2018 22:00", 0), true,
                    200);
            workingTasks.clear();
            workingTasks.add(task1);
            workingTasks.add(task2);
            workingTasks.add(task3);
            taskManager.newList(workingTasks);
        } catch (Exception e) {
            System.out.println("error in setting up "+e);
        }
    }

    @After
    public void tearDown() throws Exception {
        taskManager.newList(existingTasks);
    }

    @Test
    public void testgetNumberOfTasksCommand() {
        assertEquals(taskManager.getNumberOfTasks(), 3);
    }
    
    
    /*
     * Please note, with changes to execute command, these tests need to be rewritten slightly!
     */
    
//    @Test
//    public void testAddCommand() throws NoInputException, InvalidInputException, InvalidTaskTimeException, TaskTimeOutOfBoundException, TaskDateAlreadyPassedException, InvalidTaskDateException, ArgumentForEditingNotEnteredException, InvalidDateTimeFormatException {
//
//        //taskManager.executeCommand("add 4th || 22/11/2022 19:00 2.2");
//        assertEquals(taskManager.getNumberOfTasks(), 4);
////        taskManager.executeCommand("add 4th || 27/11/2022 19:00 2.2");
////        taskManager.executeCommand("add 3.5th || 24/11/2022 19:00 2.2");
////        taskManager.executeCommand("add 5th || 28/11/2022 19:00 2.2");
//        assertEquals(taskManager.getNumberOfTasks(), 6);
//        String[] haha = taskManager.getTaskNames();
//        for(String t:haha){
//        System.out.println(t);}
////        assertEquals(taskManager.getTaskNames(), 5);
//    }
//    
//    @Test
//    public void testDeleteCommand() throws NoInputException, InvalidInputException, InvalidTaskTimeException, TaskTimeOutOfBoundException, TaskDateAlreadyPassedException, InvalidTaskDateException, ArgumentForEditingNotEnteredException, InvalidDateTimeFormatException {
//        //taskManager.executeCommand("delete 1");
//        System.out.println(taskManager.getTaskNames()[1]);
//        assertEquals(taskManager.getNumberOfTasks(), 2);
//    }
//    
    
    /*
     * String[] columns = new String[] {"Task Name", "Task Duration", "Task Date and Time", "Task Completion"};
		List<Task> tasks = taskManager.getTasks();
		Object[][] data = new Object[taskManager.getNumberOfTasks()][4];
		for (int i = 0; i < taskManager.getNumberOfTasks(); i++) {
			for (int j = 0; j < 4; j++) {
				switch(j) {
				case 0:
					data[i][j] = tasks.get(i).getName();
					break;
				case 1:
					if (tasks.get(i).getDuration() != 0) {
						data[i][j] = tasks.get(i).getDuration();
					} else {
						data[i][j] = "N/A";
					}
					break;
				case 2:
					if (tasks.get(i).getTimeStart() != null) {
						data[i][j] = tasks.get(i).getTimeStart();
					} else {
						data[i][j] = "N/A";
					}
					break;
				default:
					data[i][j] = tasks.get(i).getDoneStatus();
					break;
					
				}
			}
		}
		
		table = new JTable(data, columns);
     */
   
    
}
```
